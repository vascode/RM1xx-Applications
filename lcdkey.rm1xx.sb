//******************************************************************************
// Copyright (c) 2016, Laird
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier:ISC
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This application ineracts with the OSEPP 16 x 2 LCD and keypad. The LCD is 
// controlled using a 4-bit wide parallel bus and two control lines. The code
// below is based on the LiquidCrystal Library for the Arduino platform.
// https://www.arduino.cc/en/Reference/LiquidCrystal
//
// The LCD module uses the SPLC780D 16 COMs x 40 SEGs dot-matrix LCD controller 
// and driver - See more at: 
// http://osepp.com/products/shield-arduino-compatible/16x2-lcd-display-keypad-shield/#sthash.7z3CTc51.dpuf
// 
// In addition to the LCD, there is are 5 push buttons that correspond to up, 
// down, left, right and select. These push buttons are connected to a single
// analog input. By reading the voltage on the analog pin, the application can
// tell which button has been pressed.
//
// This applicaiton will display which button has been pressed on the LCD.
//
// Please see the corresponding application note for directions on how to 
// configure the RM1xx DVK for this application.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//******************************************************************************
//Pin definitions for the LCD
#define RS_PIN                  0
#define ENABLE_PIN              17
#define D0_PIN                  3
#define D1_PIN                  4
#define D2_PIN                  5
#define D3_PIN                  30

//Pin definitions for the push buttons
#define PUSH_BUTTONS            6

#define DIGITAL_IN              1
#define DIGITAL_OUT             2
#define ANALOG_IN               3

#define TEN_BIT_ADC_UNITY       0x11
#define TEN_BIT_ADC_ONETHIRD    0x13
#define TEN_BIT_ADC_TWOTHIRD    0x00 //System default

//Commands
#define LCD_CLEARDISPLAY        0x01
#define LCD_RETURNHOME          0x02
#define LCD_ENTRYMODESET        0x04
#define LCD_DISPLAYCONTROL      0x08
#define LCD_CURSORSHIFT         0x10
#define LCD_FUNCTIONSET         0x20
#define LCD_SETCGRAMADDR        0x40
#define LCD_SETDDRAMADDR        0x80

//Flags for display entry mode
#define LCD_ENTRYRIGHT          0x00
#define LCD_ENTRYLEFT           0x02
#define LCD_ENTRYSHIFTINCREMENT 0x01
#define LCD_ENTRYSHIFTDECREMENT 0x00

//Flags for display on/off control
#define LCD_DISPLAYON           0x04
#define LCD_DISPLAYOFF          0x00
#define LCD_CURSORON            0x02
#define LCD_CURSOROFF           0x00
#define LCD_BLINKON             0x01
#define LCD_BLINKOFF            0x00

//Flags for display/cursor shift
#define LCD_DISPLAYMOVE         0x08
#define LCD_CURSORMOVE          0x00
#define LCD_MOVERIGHT           0x04
#define LCD_MOVELEFT            0x00

//Flags for function set
#define LCD_8BITMODE            0x10
#define LCD_4BITMODE            0x00
#define LCD_2LINE               0x08
#define LCD_1LINE               0x00
#define LCD_5x10DOTS            0x04
#define LCD_5x8DOTS             0x00

dim rc
dim adcVal
dim displayControl
dim displayMode
dim s$

//Sleep for ms milliseconds
sub Sleep(ms)
    dim C, E
    C = 0
    E = GETTICKCOUNT() + ms
    while (C < E)
        C = GETTICKCOUNT()
    endwhile
endsub

function InitPins()
    //Set all of the LCD pins as digital outputs
    rc=GpioSetFunc(RS_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising RS_PIN\n"
        exitfunc rc
    endif
    rc=GpioSetFunc(ENABLE_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising ENABLE_PIN\n"
        exitfunc rc
    endif
    rc=GpioSetFunc(D0_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising D0\n"
        exitfunc rc
    endif
    rc=GpioSetFunc(D1_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising D1\n"
        exitfunc rc
    endif
    rc=GpioSetFunc(D2_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising D2\n"
        exitfunc rc
    endif
    rc=GpioSetFunc(D3_PIN, DIGITAL_OUT, 0)
    if (rc != 0) then
        print "Error initialising D3\n"
        exitfunc rc
    endif

    //Assign all of the pushbutton pins to one analog input
    rc=GpioSetFunc(PUSH_BUTTONS, ANALOG_IN, TEN_BIT_ADC_UNITY)
    if (rc != 0) then
        print "Error initialising PUSH BUTTON ADC\n"
        exitfunc rc
    endif
    print "Successfully initialised GPIOs\n"
endfunc rc

sub PulseEnable()
    GpioWrite(ENABLE_PIN, 0)
    Sleep(1)
    GpioWrite(ENABLE_PIN, 1)
    Sleep(1) //Enable pulse must be >450ns
    GpioWrite(ENABLE_PIN, 0)
    Sleep(1) //Commands need > 37us to settle
endsub

sub Write4Bits(value)
    dim val
    val = ((value >> 0) & 0x01)
    GpioWrite(D0_PIN, ((value >> 0) & 0x01))
    val = ((value >> 1) & 0x01)
    GpioWrite(D1_PIN, ((value >> 1) & 0x01))
    val = ((value >> 2) & 0x01)
    GpioWrite(D2_PIN, ((value >> 2) & 0x01))
    val = ((value >> 3) & 0x01)
    GpioWrite(D3_PIN, ((value >> 3) & 0x01))    
    PulseEnable()
endsub

sub lcdCommand(value)
    GpioWrite(RS_PIN, 0)

    //Send an 8-bit command to the LCD
    Write4Bits(value>>4)
    Write4Bits(value)
endsub

sub lcdWrite(char)
    GpioWrite(RS_PIN, 1)

    //Send an 8-bit command to the LCD
    Write4Bits(char>>4)
    Write4Bits(char)
endsub   

sub lcdPrint(string$)
    dim index
    index = 0
        
    while index < strlen(string$)
        lcdWrite(STRGETCHR(string$, index))
        index = index + 1
    endwhile
endsub

sub lcdClear()
    lcdCommand(LCD_CLEARDISPLAY)
    Sleep(2)
endsub

sub lcdHome()
    lcdCommand(LCD_RETURNHOME)
    Sleep(2)
endsub

sub lcdSetCursor(col, row)
    lcdCommand(LCD_SETDDRAMADDR | (col + (row*0x40)))
endsub

sub lcdScrollLeft()
    lcdCommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT)
endsub

sub lcdFlushLeft()
    dim index : index = 0
    while index < 16
        lcdScrollLeft()
        Sleep(250)
        index = index+1
    endwhile
endsub

sub lcdScrollRight()
    lcdCommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT)
endsub

//Turn the display on/off (quickly)
sub lcdNoDisplay()
    displayControl = (displayControl& ~LCD_DISPLAYON)
    lcdCommand(LCD_DISPLAYCONTROL | displayControl)
endsub

sub lcdDisplay()
    displayControl = (displayControl | LCD_DISPLAYON)
    lcdCommand(LCD_DISPLAYCONTROL | displayControl)
endsub

sub lcdBegin()
    rc=InitPins()
    if (rc != 0) then
        print "error initialising GPIO pins\n"
    endif   
    
    //Put the LCD into 4 bit or 8 bit mode
    Write4Bits(0x03)
    Sleep(5) //Wait min 4.1ms
    //Second try
    Write4Bits(0x03)
    Sleep(5) //Wait min 4.1ms
    //Third go!
    Write4Bits(0x03)
    Sleep(1)
    //Finally, set to 4-bit interface
    Write4Bits(0x02) 
    
    //Turn the display on with no cursor or blinking default
    displayControl = (LCD_CURSOROFF | LCD_BLINKOFF)
    lcdDisplay()
    
    //Initialise to default text direction (for romance languages)
    displayMode = (LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT)

    //Set the entry mode
    lcdCommand(LCD_ENTRYMODESET | displayMode)
endsub

sub LeftButton()
    lcdClear()
    s$="Left"
    lcdPrint(s$)
    print "Left\n"
endsub

sub RightButton()
    lcdClear()
    s$="Right"
    lcdPrint(s$)
    print "Right\n"
endsub

sub UpButton()
    lcdClear()
    s$="Up"
    lcdPrint(s$)
    print "Up\n"
endsub

sub DownButton()
    lcdClear()
    s$="Down"
    lcdPrint(s$)
    print "Down\n"
endsub

sub SelectButton()
    lcdClear()
    s$="Select"
    lcdPrint(s$)
    print "Select\n"
endsub

sub CheckButtons(adcVal)
    if (adcVal <= 50) then
        RightButton()
    elseif (adcVal <= 105) then
        UpButton()
    elseif (adcVal <= 250) then
        DownButton()
    elseif (adcVal <= 400) then
        LeftButton()
    elseif (adcVal <= 620) then
        SelectButton()
    endif
endsub

lcdBegin()
lcdClear()

s$ = "Press some"
lcdPrint(s$)
s$ = "buttons!"
lcdSetCursor(0,1)
lcdPrint(s$)
print "Press some buttons\n"

//Loop and check the push buttons
do
    adcVal = gpioread(PUSH_BUTTONS)
    checkButtons(adcVal)
    sleep(100)
dowhile 1

waitevent
